"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __importDefault(require("crypto"));
function isNonEmptyString(s) {
    return typeof s === 'string' && s.length > 0;
}
exports.isNonEmptyString = isNonEmptyString;
function mkDeferred() {
    let resolvePromise;
    let rejectPromise;
    const promise = new Promise((resolve, reject) => {
        resolvePromise = resolve;
        rejectPromise = reject;
    });
    return {
        resolve: (value) => resolvePromise(value),
        reject: (error) => rejectPromise(error),
        promise
    };
}
exports.mkDeferred = mkDeferred;
function genRandom(size) {
    return crypto_1.default.randomBytes(size);
}
exports.genRandom = genRandom;
function genRandomString(size) {
    return genRandom(size).toString('hex');
}
exports.genRandomString = genRandomString;
function sha256(value) {
    return crypto_1.default.createHash('sha256').update(value).digest();
}
exports.sha256 = sha256;
function encodeBase64(value) {
    return value
        .toString('base64')
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=/g, '');
}
exports.encodeBase64 = encodeBase64;
/**
 * Returns a promise that ALWAYS REJECTS after `duration`.
 */
function startTimeout(duration) {
    let cancel;
    const promise = new Promise((_, reject) => {
        const timeout = setTimeout(reject, duration);
        cancel = () => { clearTimeout(timeout); };
    });
    return {
        cancel: () => cancel(),
        promise
    };
}
exports.startTimeout = startTimeout;
//# sourceMappingURL=utils.js.map