import { TAbi, TAuthority } from "../types";
import Blockchain from "./blockchain";
import Contract from "./contract";
import { TAccountMetadataObject } from "./snapshot/section-serializers/account-metadata-object-section";
import { TAccountObject } from "./snapshot/section-serializers/account-object-section";
declare type TAccountInfo = TAccountMetadataObject & TAccountObject;
export default class Account {
    private blockchain;
    /**
     * Account's on-chain name
     */
    readonly accountName: string;
    private accInfo;
    codeHash: string;
    abi?: TAbi;
    /**
     * Account's contract object
     */
    contract: ReturnType<Contract<any>["_createContractObject"]>;
    constructor(blockchain: Blockchain, accountName: string, accInfo: TAccountInfo);
    _updateAccountInfo(accInfo: TAccountInfo): void;
    /**
     * Sets contract and ABI of this account
     */
    setContract(contract: Contract<any>): Account;
    /**
     * Gets the table rows of the specified table, keyed by scopes
     */
    getTableRowsScoped(tableName: string): import("../types").TContractsTableScoped;
    /**
     * Deletes this account's table data. The table names to delete can be passed as arguments.
     * If no arguments are passed, deletes all table data of this account.
     */
    resetTables(...tableNames: string[]): void;
    /**
     * Loads initial contract data defined for the currently deployed contract.
     * If no arguments are defined, it loads the data from the JSON fixture files.
     * If tableName and fixtureScopeRowsMap are defined, it will only load the table data given by the fixtureScopeRowsMap argument
     */
    loadFixtures(tableName?: string, fixtureScopeRowsMap?: {
        [key: string]: any[];
    }): Promise<void>;
    /**
     * Updates account's authorization.
     */
    updateAuth(permissionName: string, parentPermissionName: string, auth: Partial<TAuthority>): Account;
}
export {};
