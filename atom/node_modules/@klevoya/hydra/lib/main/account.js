"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const contract_1 = tslib_1.__importDefault(require("./contract"));
const serialized_types_1 = require("./snapshot/serializer/serialized-types");
class Account {
    /* eslint-enable quotes */
    constructor(blockchain, accountName, accInfo) {
        /* eslint-disable quotes */
        /**
         * Account's contract object
         */
        this.contract = {};
        this.blockchain = blockchain;
        this.accountName = accountName;
        this._updateAccountInfo(accInfo);
    }
    _updateAccountInfo(accInfo) {
        if (accInfo.name !== this.accountName)
            throw new Error(`Cannot update account "${this.accountName}" with account info from "${accInfo.name}"`);
        this.accInfo = accInfo;
        this.codeHash = accInfo.code_hash.toLowerCase();
        if (this.accInfo.abi) {
            const abi = serialized_types_1.rawAbiToJson(this.accInfo.abi);
            this.abi = abi;
            this.contract = contract_1.default.__createContractObject(this.accountName, abi, this.blockchain);
        }
    }
    /**
     * Sets contract and ABI of this account
     */
    setContract(contract) {
        return this.blockchain.setContract(this.accountName, contract);
    }
    /**
     * Gets the table rows of the specified table, keyed by scopes
     */
    getTableRowsScoped(tableName) {
        return this.blockchain.getTableRowsScoped(this.accountName, tableName);
    }
    /**
     * Deletes this account's table data. The table names to delete can be passed as arguments.
     * If no arguments are passed, deletes all table data of this account.
     */
    resetTables(...tableNames) {
        return this.blockchain.resetTables(this.accountName, ...tableNames);
    }
    /**
     * Loads initial contract data defined for the currently deployed contract.
     * If no arguments are defined, it loads the data from the JSON fixture files.
     * If tableName and fixtureScopeRowsMap are defined, it will only load the table data given by the fixtureScopeRowsMap argument
     */
    loadFixtures(tableName, fixtureScopeRowsMap) {
        return this.blockchain.loadFixtures(this.accountName, tableName, fixtureScopeRowsMap);
    }
    /**
     * Updates account's authorization.
     */
    updateAuth(permissionName, parentPermissionName, auth) {
        return this.blockchain.updateAuth(this.accountName, permissionName, parentPermissionName, auth);
    }
}
exports.default = Account;
