"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const buffer_1 = require("../serializer/buffer");
const abstract_section_1 = tslib_1.__importDefault(require("./abstract-section"));
const serialized_types_1 = require("../serializer/serialized-types");
const eosio_abi_json_1 = tslib_1.__importDefault(require("../serializer/eosio.abi.json"));
const eosioAbi = eosio_abi_json_1.default;
class GeneratedTransactionObjectSerializer extends abstract_section_1.default {
    constructor(buf, rowCount, sectionName) {
        super(buf, rowCount, sectionName);
        this.deferredTransactions = [];
        this.deserialize();
    }
    deserializeTransactionData(accountAbiMap) {
        this.deferredTransactions = [];
        const deferredTransactions = this.data.map(genTxObj => {
            const buf = buffer_1.createSerialBuffer(Buffer.from(genTxObj.packed_trx, `binary`));
            const abiTypes = serialized_types_1.createTypeSerializer(eosioAbi);
            const txDefinition = abiTypes.get(`transaction`);
            const tx = txDefinition.deserialize(buf);
            tx.actions.forEach(action => {
                const abi = accountAbiMap[action.account];
                if (!abi)
                    return;
                const serializedAbiTypes = serialized_types_1.createTypeSerializer(abi);
                const actionDef = abi.actions.find(t => t.name === action.name);
                if (!actionDef) {
                    console.warn(`Warning: Tried to parse action "${action.account}@${action.name}" but was not found in ABI`);
                    return;
                }
                const type = serializedAbiTypes.get(actionDef.type);
                if (!type) {
                    console.warn(`Warning: Tried to parse type "${actionDef.type}" but was not found in ${action.account}'s ABI`);
                    return;
                }
                action.data = type.deserialize(buffer_1.createSerialBuffer(Buffer.from(action.data, `hex`)));
            });
            return Object.assign(Object.assign({}, tx), { sender: genTxObj.sender, sender_id: genTxObj.sender_id, payer: genTxObj.payer });
        });
        this.deferredTransactions = deferredTransactions;
    }
    deserialize() {
        const data = [];
        while (this.hasMoreRows()) {
            const row = this.readRow(`generated_transaction_object`);
            data.push(row);
        }
        this.data = data;
    }
    serialize() {
        const rows = this.data || [];
        const rowCount = rows.length;
        const buf = buffer_1.createSerialBuffer();
        this.serializeHeader(buf, rowCount);
        for (const row of rows) {
            this.serializeRow(buf, `generated_transaction_object`, row);
        }
        return Buffer.from(buf.asUint8Array());
    }
}
exports.default = GeneratedTransactionObjectSerializer;
