"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const abstract_section_1 = tslib_1.__importDefault(require("./abstract-section"));
const buffer_1 = require("../serializer/buffer");
const serialized_types_1 = require("../serializer/serialized-types");
const contractDatabaseIndexSet = [
    `key_value_object`,
    `index64_object`,
    `index128_object`,
    `index256_object`,
    `index_double_object`,
    `index_long_double_object`,
];
class ContractTablesSerializer extends abstract_section_1.default {
    constructor(buf, rowCount, sectionName) {
        super(buf, rowCount, sectionName);
        // stores the actual key_value_object for table_id_object (code, table, scope) of "non-secondary" table_id_objects
        this.accountTables = {};
        this.data = new Map();
        this.deserialize();
    }
    deserialize() {
        const accountTables = {};
        // see read_contract_tables_from_snapshot
        // first row: table_id_object
        // following rows: the 6 indexes in contract_database_index_set
        while (this.hasMoreRows()) {
            const tableIdObject = this.readRow(`table_id_object`);
            const skipRow = tableIdObject.table.length === 13; // if it's a secondary index table, it does not contain any key value object
            let accountTablesRows;
            const dataKey = [
                tableIdObject.code,
                tableIdObject.table,
                tableIdObject.scope,
            ];
            const dataValue = {
                tableIdObject,
                indexSet: Array.from({ length: contractDatabaseIndexSet.length }, () => []),
            };
            if (!skipRow) {
                if (!accountTables[tableIdObject.code])
                    accountTables[tableIdObject.code] = {};
                if (!accountTables[tableIdObject.code][tableIdObject.table])
                    accountTables[tableIdObject.code][tableIdObject.table] = {};
                if (!accountTables[tableIdObject.code][tableIdObject.table][tableIdObject.scope])
                    accountTables[tableIdObject.code][tableIdObject.table][tableIdObject.scope] = [];
                accountTablesRows =
                    accountTables[tableIdObject.code][tableIdObject.table][tableIdObject.scope];
            }
            // iterate contract_database_index_set
            // key_value_index
            let numObjects = this.readRow(`varuint32`);
            for (let i = 0; i < numObjects; i++) {
                const keyValueObject = this.readRow(contractDatabaseIndexSet[0]);
                dataValue.indexSet[0].push(keyValueObject);
                if (!skipRow) {
                    accountTablesRows.push(keyValueObject.value);
                }
            }
            // index64_index, index128_index, index256_index, index_double_index, index_long_double_index
            for (let contractDatabaseIndexIndex = 1; contractDatabaseIndexIndex < contractDatabaseIndexSet.length; contractDatabaseIndexIndex++) {
                numObjects = this.readRow(`varuint32`);
                for (let i = 0; i < numObjects; i++) {
                    const row = this.readRow(contractDatabaseIndexSet[contractDatabaseIndexIndex]);
                    dataValue.indexSet[contractDatabaseIndexIndex].push(row);
                }
            }
            this.data.set(dataKey, dataValue);
        }
        this.accountTables = accountTables;
    }
    deserializeRowsValues(accountAbiMap) {
        Object.entries(this.accountTables || {}).forEach(([code, tables]) => {
            const abi = accountAbiMap[code];
            if (!abi)
                return;
            const serializedAbiTypes = serialized_types_1.createTypeSerializer(abi);
            Object.entries(tables).forEach(([tableName, scopes]) => {
                const tableDef = abi.tables.find(t => t.name === tableName);
                if (!tableDef) {
                    console.warn(`Warning: Tried to parse table "${tableName}" but was not found in ABI`);
                    return;
                }
                const type = serializedAbiTypes.get(tableDef.type);
                if (!type) {
                    console.warn(`Warning: Tried to parse type "${tableDef.type}" but was not found in ABI`);
                    return;
                }
                Object.values(scopes).forEach(rows => {
                    rows.forEach((rowValue, index) => {
                        rows[index] = type.deserialize(buffer_1.createSerialBuffer(Buffer.from(rowValue)));
                    });
                });
            });
        });
    }
    serialize() {
        const rows = this.data || [];
        let rowCount = 0;
        for (const [key, value] of rows) {
            rowCount += 1 + contractDatabaseIndexSet.length; // tableIdObject + rowCount for indexes
            const actualObjectsCount = value.indexSet.reduce((acc, indexRows) => acc + indexRows.length, 0);
            rowCount += actualObjectsCount;
        }
        const buf = buffer_1.createSerialBuffer();
        this.serializeHeader(buf, rowCount);
        for (const [key, value] of rows) {
            this.serializeRow(buf, `table_id_object`, value.tableIdObject);
            value.indexSet.forEach((indexRows, contractDatabaseIndexIndex) => {
                this.serializeRow(buf, `varuint32`, indexRows.length);
                indexRows.forEach(object => {
                    this.serializeRow(buf, contractDatabaseIndexSet[contractDatabaseIndexIndex], object);
                });
            });
        }
        return Buffer.from(buf.asUint8Array());
    }
}
exports.default = ContractTablesSerializer;
