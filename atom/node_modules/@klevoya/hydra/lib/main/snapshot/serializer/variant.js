"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var VariantType;
(function (VariantType) {
    VariantType[VariantType["null_type"] = 0] = "null_type";
    VariantType[VariantType["int64_type"] = 1] = "int64_type";
    VariantType[VariantType["uint64_type"] = 2] = "uint64_type";
    VariantType[VariantType["double_type"] = 3] = "double_type";
    VariantType[VariantType["bool_type"] = 4] = "bool_type";
    VariantType[VariantType["string_type"] = 5] = "string_type";
    VariantType[VariantType["array_type"] = 6] = "array_type";
    VariantType[VariantType["object_type"] = 7] = "object_type";
    VariantType[VariantType["blob_type"] = 8] = "blob_type";
})(VariantType || (VariantType = {}));
const deserialize = (buffer) => {
    const variantType = buffer.getVaruint32();
    // console.log(
    //   `variantType`,
    //   VariantType[variantType],
    //   buffer.readPos,
    //   buffer.length - buffer.readPos
    // );
    switch (variantType) {
        case VariantType.null_type: {
            return null;
        }
        case VariantType.int64_type: {
            // we want txTrace.elapsed, blockNumber, etc. to be of type 'number'
            // return buffer.getInt64AsDecimal();
            return buffer.getInt64AsNumber();
        }
        case VariantType.uint64_type: {
            // we want txTrace.elapsed, blockNumber, etc. to be of type 'number'
            // return buffer.getUint64AsDecimal();
            return buffer.getUint64AsNumber();
        }
        case VariantType.double_type: {
            return buffer.getFloat64();
        }
        case VariantType.bool_type: {
            return Boolean(buffer.getUint8Array(1)[0]);
        }
        case VariantType.string_type: {
            return buffer.getString();
        }
        case VariantType.array_type: {
            const size = buffer.getVaruint32();
            const ret = [];
            for (let i = 0; i < size; i += 1) {
                ret.push(deserialize(buffer));
            }
            return ret;
        }
        case VariantType.object_type: {
            const objectSize = buffer.getVaruint32();
            const ret = {};
            for (let i = 0; i < objectSize; i += 1) {
                const key = buffer.getString();
                const value = deserialize(buffer);
                ret[key] = value;
            }
            return ret;
        }
        case VariantType.blob_type: {
            return buffer.getBytes();
        }
        default:
            throw new Error(`Variant type ${VariantType[variantType]} not supported yet`);
    }
};
const serialize = (buffer, data) => {
    const dataType = typeof data;
    // currently only works for { snapshot: buffer, tx: string } variant
    switch (dataType) {
        case `string`: {
            buffer.pushUint8(VariantType.string_type);
            buffer.pushString(data);
            break;
        }
        case `object`: {
            if (Buffer.isBuffer(data)) {
                buffer.pushUint8(VariantType.blob_type);
                buffer.pushBytes(new Uint8Array(data));
                break;
            }
            else if (Array.isArray(data)) {
                throw new Error(`Arrays not supported as a variant`);
            }
            else {
                buffer.pushUint8(VariantType.object_type);
                const keys = Object.keys(data);
                buffer.pushVaruint32(keys.length);
                keys.forEach(key => {
                    buffer.pushString(key);
                    serialize(buffer, data[key]);
                });
                break;
            }
        }
        default:
            throw new Error(`Object type ${dataType} not supported as a variant`);
    }
};
const variantObjectSerializer = {
    serialize,
    deserialize,
};
exports.default = variantObjectSerializer;
