"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const serialized_types_1 = require("./serializer/serialized-types");
const utils_1 = require("./serializer/utils");
const snapshot_serializer_1 = tslib_1.__importDefault(require("./snapshot-serializer"));
const protocol_state_object_section_1 = require("./section-serializers/protocol-state-object-section");
const eosjs_serialize_1 = require("eosjs/dist/eosjs-serialize");
class Snapshot {
    constructor() {
        this.snapshot = Buffer.from([]);
        this.sections = new Map();
        // create empty snapshot and parse it s.t. this.sections gets filled
        this.snapshot = snapshot_serializer_1.default.serialize(new Map());
        this.parseSnapshot(this.snapshot);
        // initialize
        this.initializeSections();
        this.parseSnapshot(this.snapshot);
    }
    initializeSections() {
        // create first permission that must always exist, see @authorization_manager.cpp:66::from_snapshot_row
        const permissionsSection = this.getSectionSerializer(`eosio::chain::permission_object`);
        const emptyPermission = {
            threshold: 0,
            keys: [],
            accounts: [],
            waits: []
        };
        permissionsSection.data.push({
            parent: ``,
            owner: ``,
            name: ``,
            last_updated: utils_1.createTimestamp(0),
            last_used: utils_1.createTimestamp(0),
            auth: emptyPermission
        });
        const protocolStateSection = this.getSectionSerializer(`eosio::chain::protocol_state_object`);
        protocolStateSection.data[0] = protocol_state_object_section_1.defaultProtocolStateObject;
        this.snapshot = this.serializeSnapshot();
    }
    set(snapshot) {
        this.snapshot = snapshot;
        this.parseSnapshot(this.snapshot);
        // this.print()
        // this.writeSnapshot()
    }
    parseSnapshot(snapshot) {
        this.sections = snapshot_serializer_1.default.deserialize(snapshot);
    }
    serializeSnapshot() {
        return snapshot_serializer_1.default.serialize(this.sections);
    }
    print() {
        // console.log(
        //   `==== SNAPSHOT (${(this.snapshot.byteLength / 1024).toFixed(2)}kB) ====`
        // )
        // for (const [sectionName, serializer] of this.sections) {
        //   console.log(`==== ${sectionName} ====\n${serializer.printData()}`)
        // }
    }
    writeSnapshot() {
        const serializedSnapshot = this.serializeSnapshot();
        fs_1.default.writeFileSync(`snapshot.bin`, serializedSnapshot);
    }
    createAccount(accountName, ownerAuth, activeAuth, options) {
        const accountsSection = this.getSectionSerializer(`eosio::chain::account_object`);
        const accountsMetaSection = this.getSectionSerializer(`eosio::chain::account_metadata_object`);
        const permissionsSection = this.getSectionSerializer(`eosio::chain::permission_object`);
        if (accountsSection.data.some(acc => acc.name === accountName) ||
            accountsMetaSection.data.some(acc => acc.name === accountName)) {
            throw new Error(`Account "${accountName}" already exists and cannot be created`);
        }
        accountsSection.data.push({
            name: accountName,
            creation_date: 0,
            abi: ``
        });
        accountsMetaSection.data.push({
            name: accountName,
            recv_sequence: `0`,
            auth_sequence: `0`,
            code_sequence: `0`,
            abi_sequence: `0`,
            code_hash: `0000000000000000000000000000000000000000000000000000000000000000`,
            last_code_update: utils_1.createTimestamp(0),
            flags: options && options.privileged ? 1 : 0,
            vm_type: 0,
            vm_version: 0
        });
        permissionsSection.data.push({
            parent: ``,
            owner: accountName,
            name: `owner`,
            last_updated: utils_1.createTimestamp(0),
            last_used: utils_1.createTimestamp(0),
            auth: ownerAuth
        }, {
            parent: `owner`,
            owner: accountName,
            name: `active`,
            last_updated: utils_1.createTimestamp(0),
            last_used: utils_1.createTimestamp(0),
            auth: activeAuth
        });
    }
    updateAccountAuth(accountName, permissionName, parentPermissionName, auth) {
        const accountsSection = this.getSectionSerializer(`eosio::chain::account_object`);
        const accountsMetaSection = this.getSectionSerializer(`eosio::chain::account_metadata_object`);
        const permissionsSection = this.getSectionSerializer(`eosio::chain::permission_object`);
        const accountObj = accountsSection.data.find(({ name }) => name === accountName);
        const accountMetadataObj = accountsMetaSection.data.find(({ name }) => name === accountName);
        if (!accountObj || !accountMetadataObj)
            throw new Error(`Account "${accountName} does not exist`);
        // delete the permission if it exists
        const permissionData = permissionsSection.data.filter(p => !(p.owner === accountName && p.name === permissionName));
        permissionData.push({
            parent: parentPermissionName,
            owner: accountName,
            name: permissionName,
            last_updated: utils_1.createTimestamp(0),
            last_used: utils_1.createTimestamp(0),
            auth: auth
        });
        permissionsSection.data = permissionData;
    }
    setAccountCodeAbi(accountName, abi, wasm) {
        const accountsSection = this.getSectionSerializer(`eosio::chain::account_object`);
        const accountsMetaSection = this.getSectionSerializer(`eosio::chain::account_metadata_object`);
        const codeSection = this.getSectionSerializer(`eosio::chain::code_object`);
        const accountObj = accountsSection.data.find(({ name }) => name === accountName);
        const accountMetadataObj = accountsMetaSection.data.find(({ name }) => name === accountName);
        if (!accountObj || !accountMetadataObj)
            throw new Error(`Account "${accountName} does not exist`);
        if (abi) {
            const rawAbi = serialized_types_1.jsonToRawAbi(abi);
            accountObj.abi = rawAbi.toString(`binary`); // utf8 yields to wrong length leading to failed deserialization
            accountMetadataObj.abi_sequence = String(Number.parseInt(accountMetadataObj.abi_sequence, 10) + 1);
        }
        if (wasm) {
            const codeHash = utils_1.createHash(wasm);
            const code = wasm.toString(`binary`);
            if (!codeSection.data.some(code => code.code_hash === codeHash)) {
                codeSection.data.push({
                    code_hash: codeHash,
                    code: code,
                    code_ref_count: `1`,
                    first_block_used: 0,
                    vm_type: 0,
                    vm_version: 0
                });
            }
            // update code to account
            accountMetadataObj.code_hash = codeHash;
        }
    }
    resetTables(accountName, ...tableNames) {
        const contractTablesSer = this.getSectionSerializer(`contract_tables`);
        const map = contractTablesSer.data;
        for (const [key, value] of map) {
            if (key[0] === accountName) {
                if (tableNames.length === 0 ||
                    tableNames.includes(value.tableIdObject.table)) {
                    map.delete(key);
                }
            }
        }
        // reload s.t. changes are reflected in getTableRowsScoped accountTables
        this.parseSnapshot(this.serializeSnapshot());
    }
    getTableRowsScoped(accountName, tableName) {
        const contractTablesSer = this.getSectionSerializer(`contract_tables`);
        if (!contractTablesSer)
            return {};
        const tables = contractTablesSer.accountTables[accountName];
        if (!tables || !tables[tableName])
            return {};
        return tables[tableName];
    }
    getAccountsInfo() {
        const accountsSection = this.getSectionSerializer(`eosio::chain::account_object`);
        const accountsMetaSection = this.getSectionSerializer(`eosio::chain::account_metadata_object`);
        const accountsInfo = {};
        accountsSection.data.forEach(acc => {
            accountsInfo[acc.name] = Object.assign({}, acc);
        });
        // both sections are created for every account
        accountsMetaSection.data.forEach(acc => {
            accountsInfo[acc.name] = Object.assign(Object.assign({}, accountsInfo[acc.name]), acc);
        });
        return accountsInfo;
    }
    getDeferredTransactions() {
        const deferredTxSection = this.getSectionSerializer(`eosio::chain::generated_transaction_object`);
        return deferredTxSection.deferredTransactions;
    }
    clearDeferredTransactions() {
        const deferredTxSection = this.getSectionSerializer(`eosio::chain::generated_transaction_object`);
        deferredTxSection.data = [];
        deferredTxSection.deferredTransactions = [];
    }
    setProtocolFeature(featureName, enable) {
        const protocolStateSection = this.getSectionSerializer(`eosio::chain::protocol_state_object`);
        const featureDigest = protocol_state_object_section_1.PROTOCOL_FEATURES[featureName];
        let activated_protocol_features = protocolStateSection.data[0]
            .activated_protocol_features;
        // remove duplicates
        activated_protocol_features = activated_protocol_features.filter(feature => feature.feature_digest !== featureDigest);
        if (enable) {
            activated_protocol_features.push({
                feature_digest: featureDigest,
                activation_block_num: 0
            });
        }
        protocolStateSection.data[0].activated_protocol_features = activated_protocol_features;
    }
    setCurrentTime(date) {
        // current time is encoded as creation_date on eosio account
        const accountsSection = this.getSectionSerializer(`eosio::chain::account_object`);
        const eosioAccount = accountsSection.data.find(acc => acc.name === `eosio`);
        // creation date is a block_timestamp_type, number of 0 = date of 2000-01-01
        const TIME_POINT_ZERO = 946684800;
        if (!eosioAccount || date.getTime() < TIME_POINT_ZERO * 1000) {
            throw new Error(`Could not set current time`);
        }
        // convert to half seconds since 2000
        const timePointSec = eosjs_serialize_1.dateToBlockTimestamp(date.toISOString().slice(0, -1));
        eosioAccount.creation_date = timePointSec;
    }
    getSectionSerializer(sectionName) {
        switch (sectionName) {
            case `contract_tables`: {
                return this.sections.get(sectionName);
            }
            case `eosio::chain::account_object`: {
                return this.sections.get(sectionName);
            }
            case `eosio::chain::account_metadata_object`: {
                return this.sections.get(sectionName);
            }
            case `eosio::chain::code_object`: {
                return this.sections.get(sectionName);
            }
            case `eosio::chain::permission_object`: {
                return this.sections.get(sectionName);
            }
            case `eosio::chain::permission_link_object`: {
                return this.sections.get(sectionName);
            }
            case `eosio::chain::generated_transaction_object`: {
                return this.sections.get(sectionName);
            }
            case `eosio::chain::protocol_state_object`: {
                return this.sections.get(sectionName);
            }
            default:
                throw new Error(`No Section Serializer implemented for section "${sectionName}"`);
        }
    }
}
exports.default = Snapshot;
