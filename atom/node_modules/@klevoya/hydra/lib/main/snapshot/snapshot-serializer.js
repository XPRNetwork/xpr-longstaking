"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const _ = tslib_1.__importStar(require("lodash"));
const buffer_1 = require("./serializer/buffer");
const section_serializers_1 = require("./section-serializers");
const serialized_types_1 = require("./serializer/serialized-types");
// see hydra/eos/libraries/chain/include/eosio/chain/snapshot.hpp
class SnapshotSerializer {
    static deserialize(snapshot) {
        const buf = buffer_1.createSerialBuffer(snapshot);
        const magicNumber = buf.getUint32();
        const version = buf.getUint32();
        if (magicNumber !== this.MAGIC_NUMBER)
            throw new Error(`Invalid snapshot: Wrong magic number`);
        if (version !== 1)
            throw new Error(`Invalid snapshot: Wrong version number`);
        const sections = this.deserializeSections(buf);
        if (sections.has(`contract_tables`) &&
            sections.has(`eosio::chain::account_object`)) {
            const accountObjects = sections.get(`eosio::chain::account_object`).data;
            const accountsAbiMap = _.mapValues(_.keyBy(accountObjects, row => row.name), row => serialized_types_1.rawAbiToJson(row.abi));
            sections.get(`contract_tables`).deserializeRowsValues(accountsAbiMap);
            sections.get(`eosio::chain::generated_transaction_object`).deserializeTransactionData(accountsAbiMap);
        }
        // create each section so we don't have to check for existence every time when reading / creating
        this.createEmptySections(sections);
        return sections;
    }
    static createEmptySections(sections) {
        section_serializers_1.SNAPSHOT_SECTION_NAMES.forEach(sectionName => {
            if (!sections.has(sectionName)) {
                const sectionBuf = buffer_1.createSerialBuffer();
                const rowCount = 0;
                sectionBuf.pushNumberAsUint64(rowCount);
                sectionBuf.pushCString(sectionName);
                const serializer = section_serializers_1.sectionSerializerFactory(sectionBuf, 0, sectionName);
                sections.set(sectionName, serializer);
            }
        });
    }
    static deserializeSections(buf) {
        let sectionSize = buf.getUint64AsDecimal();
        const sections = new Map();
        // end marker (0xFFFF FFFF FFFF FFFF)
        while (sectionSize !== `18446744073709551615`) {
            const sectionBuf = buffer_1.createSerialBuffer(Buffer.from(buf.getUint8Array(Number.parseInt(sectionSize, 10))));
            const rowCount = sectionBuf.getUint64AsNumber();
            const sectionName = sectionBuf.getCString();
            // console.log(`deserializing section ${sectionName}, ${sectionSize}`)
            sections.set(sectionName, section_serializers_1.sectionSerializerFactory(sectionBuf, rowCount, sectionName));
            sectionSize = buf.getUint64AsDecimal();
        }
        return sections;
    }
    static serialize(sections) {
        const buf = buffer_1.createSerialBuffer();
        buf.pushUint32(this.MAGIC_NUMBER);
        buf.pushUint32(1);
        for (const [sectionName, serializer] of sections) {
            const sectionBuffer = serializer.serialize();
            const sectionSize = sectionBuffer.byteLength;
            // console.log(`serializing section ${sectionName}, ${sectionSize}`)
            buf.pushNumberAsUint64(sectionSize);
            buf.pushArray(sectionBuffer);
        }
        // push section end marker
        buf.pushUint32(0xFFFFFFFF);
        buf.pushUint32(0xFFFFFFFF);
        return Buffer.from(buf.asUint8Array());
    }
}
exports.default = SnapshotSerializer;
SnapshotSerializer.MAGIC_NUMBER = 0x30510550;
