"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const contract_1 = tslib_1.__importDefault(require("./contract"));
const snapshot_1 = tslib_1.__importDefault(require("./snapshot"));
const api_1 = tslib_1.__importDefault(require("./api"));
const fs = tslib_1.__importStar(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const globby_1 = tslib_1.__importDefault(require("globby"));
const account_1 = tslib_1.__importDefault(require("./account"));
const eosio_system_abi_json_1 = tslib_1.__importDefault(require("../templates/eosio.system.abi.json"));
const proxy_1 = require("../utils/proxy");
const serialized_types_1 = require("./snapshot/serializer/serialized-types");
const buffer_1 = require("./snapshot/serializer/buffer");
const eos_1 = require("../utils/eos");
const eosioSystemAbi = eosio_system_abi_json_1.default;
const emptyAuth = {
    threshold: 1,
    keys: [],
    accounts: [],
    waits: []
};
const defaultAuth = {
    threshold: 1,
    keys: [{ key: `EOS1111111111111111111111111111111114T1Anm`, weight: 1 }],
    accounts: [],
    waits: []
};
class Blockchain {
    /**
     * Creates a new blockchain object
     */
    constructor(config) {
        this._contracts = {};
        this._accounts = {};
        /**
         * Executes a transactions
         */
        this.sendTransaction = async (transaction) => {
            const currentSnapshot = this._snapshot.serializeSnapshot();
            this._snapshot.print();
            const payload = {
                snapshot: currentSnapshot,
                tx: JSON.stringify(transaction)
            };
            const result = await this._api.pushTransaction(payload);
            this._onPostTransaction(result.snapshot);
            return result.trace;
        };
        /**
         * Sets the current time of the blockchain changing the value returned
         * by eosio::current_time_point and similar intrinsics
         */
        this.setCurrentTime = (date) => {
            if (!(date instanceof Date))
                throw new Error(`Must pass a "Date" object to setCurrentTime: Passed ${date}`);
            this._snapshot.setCurrentTime(date);
        };
        Object.values(config.contracts).forEach(contract => {
            this._contracts[contract.name] = new contract_1.default(this, contract);
        });
        this._addDefaultContractTemplates();
        this._api = new api_1.default(config.options);
        this._snapshot = this._createInitialSnapshot();
        this._updateAccounts();
    }
    _addDefaultContractTemplates() {
        if (!this._contracts[`eosio.token`]) {
            this._contracts[`eosio.token`] = new contract_1.default(this, {
                name: `eosio.token`,
                wasm: path.resolve(__dirname, `../templates/contracts/eosio.token/eosio.token-v1.7.0.wasm`),
                abi: path.resolve(__dirname, `../templates/contracts/eosio.token/eosio.token-v1.7.0.abi`),
                fixturesDir: `tests/fixtures/eosio.token`
            });
        }
        if (!this._contracts[`eosio.system`]) {
            this._contracts[`eosio.system`] = new contract_1.default(this, {
                name: `eosio.system`,
                wasm: path.resolve(__dirname, `../templates/contracts/eosio.system/eosio.system-v1.9.0.wasm`),
                abi: path.resolve(__dirname, `../templates/contracts/eosio.system/eosio.system-v1.9.0.abi`),
                fixturesDir: `tests/fixtures/eosio.system`
            });
        }
    }
    _createInitialSnapshot() {
        const snapshot = new snapshot_1.default();
        // snapshot.set(
        //   readFileSync(`snapshot_ser.bin`)
        // )
        snapshot.createAccount(`eosio`, defaultAuth, defaultAuth, {
            privileged: true
        });
        snapshot.setAccountCodeAbi(`eosio`, eosioSystemAbi);
        return snapshot;
    }
    /**
     * Gets configured contract templates that can be used for setContract.
     */
    get contractTemplates() {
        return Object.assign({}, this._contracts);
    }
    /**
     * Gets all user-created and default-created accounts. Keyed by account name
     */
    get accounts() {
        return Object.assign({}, this._accounts);
    }
    getTableRowsScoped(accountName, tableName) {
        const dict = this._snapshot.getTableRowsScoped(accountName, tableName);
        const proxy = new Proxy(dict, proxy_1.nameProxyHandler);
        return proxy;
    }
    /**
     * Creates a new account
     */
    createAccount(accountName, ownerAuth, activeAuth) {
        this._snapshot.createAccount(accountName, ownerAuth || defaultAuth, activeAuth || defaultAuth);
        this._updateAccounts();
        return this.accounts[accountName];
    }
    updateAuth(accountName, permissionName, parentPermissionName, auth) {
        const _auth = Object.assign(Object.assign({}, defaultAuth), auth);
        this._snapshot.updateAccountAuth(accountName, permissionName, parentPermissionName, _auth);
        this._updateAccounts();
        return this.accounts[accountName];
    }
    setContract(accountName, contract) {
        if (!contract)
            throw new Error(`No contract template passed for "${accountName}.setContract"`);
        if (!(contract instanceof contract_1.default))
            throw new Error(`Must pass a contract template to blockchain.setContract`);
        this._snapshot.setAccountCodeAbi(accountName, contract.abi, contract.wasm);
        this._updateAccounts();
        return this.accounts[accountName];
    }
    resetTables(accountName, ...tableNames) {
        this._snapshot.resetTables(accountName, ...tableNames);
    }
    async getJsonFixtures(accountName, contractTemplate) {
        const { fixturesDir } = contractTemplate.config;
        if (!fixturesDir)
            throw new Error(`Cannot load fixtures for account "${accountName}": No fixture path was defined for contract "${contractTemplate.config.name}".`);
        const transform = (filePath) => {
            return {
                filePath,
                tableName: path.basename(filePath, path.extname(filePath))
            };
        };
        const fixtures = (await globby_1.default(`${fixturesDir}/**/*.json`))
            .map(transform)
            .map(obj => {
            const content = JSON.parse(fs.readFileSync(obj.filePath, `utf8`));
            return {
                tableName: obj.tableName,
                data: content
            };
        });
        return fixtures;
    }
    /**
     * Loads initial contract data defined for the currently deployed contract on the account.
     * If only accountName is defined, it loads the data from the JSON fixture files.
     * If tableName and fixtureScopeRowsMap are also defined, it will load the table data given by the fixtureScopeRowsMap argument
     */
    async loadFixtures(accountName, tableName, fixtureScopeRowsMap) {
        if (!accountName)
            throw new Error(`No account name passed`);
        if ((!tableName && fixtureScopeRowsMap) ||
            (tableName && !fixtureScopeRowsMap)) {
            throw new Error(`loadFixtures either takes no argument to load JSON fixtures, or a table name and the fixture data.`);
        }
        // find deployed contract on account
        const account = this.accounts[accountName];
        const { codeHash } = account;
        if (codeHash ===
            `0000000000000000000000000000000000000000000000000000000000000000`) {
            throw new Error(`Cannot load fixtures for account "${accountName}" because no code was deployed.`);
        }
        const contractTemplate = Object.values(this.contractTemplates).find(c => c.codeHash === codeHash);
        if (!contractTemplate)
            throw new Error(`Cannot load fixtures for account "${accountName}": An unknown contract with code_hash "${codeHash}" was deployed. Make sure it is added to the hydra config.`);
        const INSERT_ROW_ACTION_NAME = `hydraload`;
        if (!contractTemplate.abi.actions.some(action => action.name === INSERT_ROW_ACTION_NAME))
            throw new Error(`Cannot load fixtures for account "${accountName}": Contract "${contractTemplate.config.name}" does not have the "${INSERT_ROW_ACTION_NAME}" action. Make sure the hydra header file is added and the action is exposed in the ABI.`);
        let fixtures = [];
        if (!fixtureScopeRowsMap) {
            fixtures = await this.getJsonFixtures(accountName, contractTemplate);
        }
        else {
            fixtures = [
                {
                    tableName: tableName,
                    data: fixtureScopeRowsMap
                }
            ];
        }
        const abiSerializer = serialized_types_1.createTypeSerializer(contractTemplate.abi);
        const payload = [];
        for (const fixture of fixtures) {
            const tableDef = contractTemplate.abi.tables.find(t => t.name === fixture.tableName);
            if (!tableDef) {
                console.warn(`Could not find table "${fixture.tableName}" in "${contractTemplate.config.name}" contract to load fixtures.`);
                continue;
            }
            const tableSerializer = abiSerializer.get(tableDef.type);
            if (!tableSerializer) {
                console.warn(`Could not find table type "${tableDef.type}" in "${contractTemplate.config.name}" contract to load fixtures.`);
                continue;
            }
            for (const scope of Object.keys(fixture.data)) {
                let encodedScope = scope;
                if (!eos_1.isName(encodedScope)) {
                    encodedScope = eos_1.convertSymbolCode2Name(scope);
                }
                for (const row of fixture.data[scope]) {
                    const buf = buffer_1.createSerialBuffer();
                    tableSerializer.serialize(buf, row);
                    payload.push({
                        table_name: fixture.tableName,
                        scope: encodedScope,
                        row_data: Buffer.from(buf.asUint8Array()).toString(`hex`)
                    });
                }
            }
        }
        const action = {
            account: accountName,
            name: INSERT_ROW_ACTION_NAME,
            authorization: [{ actor: `eosio`, permission: `active` }],
            data: {
                payload
            }
        };
        await this.sendTransaction({ actions: [action] });
    }
    /**
     * Gets all deferred transactions
     */
    getDeferredTransactions() {
        return this._snapshot.getDeferredTransactions();
    }
    /**
     * Clears all deferred transactions
     */
    clearDeferredTransactions() {
        this._snapshot.clearDeferredTransactions();
    }
    /**
     * Enable or disable an EOSIO protocol feature
     */
    setProtocolFeature(featureName, enable) {
        this._snapshot.setProtocolFeature(featureName, enable);
    }
    _onPostTransaction(snapshot) {
        this._snapshot.set(snapshot);
        this._updateAccounts();
    }
    _updateAccounts() {
        const accountsInfo = this._snapshot.getAccountsInfo();
        Object.values(accountsInfo).forEach(accInfo => {
            if (this._accounts[accInfo.name]) {
                this._accounts[accInfo.name]._updateAccountInfo(accInfo);
            }
            else {
                this._accounts[accInfo.name] = new account_1.default(this, accInfo.name, accInfo);
            }
        });
    }
}
exports.default = Blockchain;
