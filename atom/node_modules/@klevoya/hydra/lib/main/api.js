"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const auth_1 = require("./auth");
const serialized_types_1 = tslib_1.__importDefault(require("./snapshot/serializer/serialized-types"));
const buffer_1 = require("./snapshot/serializer/buffer");
const extractRpcError = (err) => {
    if (!err.response || !err.response.data) {
        return err.message;
    }
    const responseData = err.response.data;
    const { code, message, error } = responseData;
    if (!code || !message) {
        // for proxy responses
        if (error)
            return error;
        return err.message;
    }
    // for eosio responses
    let msg = `${message} (${code}): ${error.what} (${error.name})`;
    const details = Array.isArray(error.details)
        ? error.details
            .map((detail) => `${detail.message} @${detail.file}:${detail.line_number}::${detail.method}`)
            .join(`;`)
        : ``;
    msg = `${msg} - ${details}`;
    return msg;
};
class ServerApi {
    constructor(options) {
        this.apiRequest = async (path, data) => {
            const resultSerializer = serialized_types_1.default.get(`variant_object`);
            try {
                if (!this.options.skipAuth) {
                    const accessToken = await auth_1.refreshAccessToken();
                    this.axios.defaults.headers.authorization = `Bearer ${accessToken}`;
                }
                const result = await this.axios.post(path, data, {
                    headers: {
                        "content-type": "application/octet-stream"
                    },
                    responseType: "arraybuffer" // important ! otherwise result.data has less bytes
                });
                const byteBuffer = new Uint8Array(result.data);
                const serialBuffer = buffer_1.createSerialBuffer(byteBuffer);
                const deserialized = resultSerializer.deserialize(serialBuffer);
                return deserialized;
            }
            catch (error) {
                if (error.response &&
                    error.response.data &&
                    Buffer.isBuffer(error.response.data)) {
                    let responseData = error.response.data;
                    if (error.response.headers[`content-type`] === `application/json`) {
                        try {
                            error.response.data = JSON.parse(responseData.toString(`utf8`));
                        }
                        catch (_err) {
                            console.error(`Error while parsing JSON encoded response data: ${_err.message}`, error.response.headers);
                        }
                    }
                    else {
                        try {
                            const byteBuffer = new Uint8Array(responseData);
                            const serialBuffer = buffer_1.createSerialBuffer(byteBuffer);
                            responseData = resultSerializer.deserialize(serialBuffer);
                            error.response.data = responseData;
                        }
                        catch (_err) {
                            console.error(`Error while parsing response data: ${_err.message}`, error.response.headers);
                        }
                    }
                }
                const errorMessage = extractRpcError(error);
                throw new Error(errorMessage);
            }
        };
        this.pushTransaction = async (data) => {
            const paramsSerializer = serialized_types_1.default.get(`variant_object`);
            const buf = buffer_1.createSerialBuffer();
            paramsSerializer.serialize(buf, data);
            const serializedData = Buffer.from(buf.asUint8Array());
            const result = await this.apiRequest(`/push_transaction`, serializedData);
            return result;
        };
        this.options = options;
        let headers = {};
        if (!options.skipAuth) {
            const auth = auth_1.getStoredAuth();
            const authToken = auth.access_token;
            headers = {
                Authorization: `Bearer ${authToken}`
            };
        }
        this.axios = axios_1.default.create({
            baseURL: `${options.serverBaseUrl}/v1/hydra`,
            // don't set a timeout here - when running many tests in parallel
            // seems like the network bus of node is full
            timeout: 0,
            headers
        });
    }
}
exports.default = ServerApi;
