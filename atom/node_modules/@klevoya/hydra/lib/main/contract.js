"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const _ = tslib_1.__importStar(require("lodash"));
const fs = tslib_1.__importStar(require("fs-extra"));
const utils_1 = require("./snapshot/serializer/utils");
class Contract {
    constructor(blockchain, contract) {
        this.blockchain = blockchain;
        this.config = contract;
        this.loadConfig(this.config);
    }
    loadConfig(config) {
        // try loading ABI
        if (!config.abi)
            throw new Error(`No ABI file specified for contract "${config.name}"`);
        const abi = _.attempt(() => JSON.parse(fs.readFileSync(config.abi, `utf8`)));
        if (_.isError(abi)) {
            throw new TypeError(`Could not read ABI for contract "${config.name}": ${abi.message}`);
        }
        this.abi = abi;
        // load WASM
        if (!config.wasm)
            throw new Error(`No WASM file specified for contract "${config.name}"`);
        const wasm = _.attempt(() => fs.readFileSync(config.wasm));
        if (_.isError(wasm)) {
            throw new TypeError(`Could not read WASM for contract "${config.name}": ${wasm.message}`);
        }
        this.wasm = wasm;
        this.codeHash = utils_1.createHash(wasm);
    }
    _createContractObject(accountName) {
        return Contract.__createContractObject(accountName, this.abi, this.blockchain);
    }
    static __createContractObject(accountName, abi, blockchain) {
        /* eslint-disable quotes */
        const contract = {};
        abi.actions.forEach(act => {
            contract[act.name] = async (data = {}, // serialization fails server-side when using undefined
            authorization = [
                { actor: accountName, permission: `active` },
            ]) => {
                if (!_.isObject(data))
                    throw new Error(`Action data must be an object, but was "${data}"`);
                const action = {
                    account: accountName,
                    name: act.name,
                    authorization: authorization,
                    data: data,
                };
                return blockchain.sendTransaction({ actions: [action] });
            };
        });
        return contract;
    }
}
exports.default = Contract;
