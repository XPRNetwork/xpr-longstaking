"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path = tslib_1.__importStar(require("path"));
const fs = tslib_1.__importStar(require("fs-extra"));
const child = tslib_1.__importStar(require("child_process"));
const command_1 = require("@oclif/command");
const globby_1 = tslib_1.__importDefault(require("globby"));
const yaml = tslib_1.__importStar(require("js-yaml"));
const inquirer = tslib_1.__importStar(require("inquirer"));
const _ = tslib_1.__importStar(require("lodash"));
const ejs = tslib_1.__importStar(require("ejs"));
const prettier_1 = tslib_1.__importDefault(require("prettier"));
const hydra_1 = require("../config/hydra");
const abi_1 = require("../utils/abi");
const toFileObjects = (filePaths) => filePaths
    .map(filePath => ({
    filePath,
    fileName: path.basename(filePath),
    fileNameNoExtension: path.basename(filePath, path.extname(filePath))
}))
    .filter(({ fileNameNoExtension }) => ![`CMakeCXXCompilerId`, `CMakeCCompilerId`].includes(fileNameNoExtension));
class Init extends command_1.Command {
    constructor() {
        super(...arguments);
        this.configDir = process.cwd();
        this.configFilePath = path.resolve(this.configDir, `./hydra.yml`);
        this.relativeToConfig = (p) => path.relative(this.configDir, p);
        this.pathFromConfig = (p) => path.join(this.configDir, p);
    }
    async getContracts(contractsDir) {
        const wasmFiles = toFileObjects(await globby_1.default(`${contractsDir}/**/*.wasm`));
        const abiFiles = toFileObjects(await globby_1.default(`${contractsDir}/**/*.abi`));
        let contracts = {};
        wasmFiles.forEach(file => {
            if (!contracts[file.fileNameNoExtension]) {
                contracts[file.fileNameNoExtension] = {
                    name: file.fileNameNoExtension,
                    wasm: this.relativeToConfig(file.filePath)
                };
            }
        });
        abiFiles.forEach(file => {
            if (!contracts[file.fileNameNoExtension]) {
                contracts[file.fileNameNoExtension] = {
                    name: file.fileNameNoExtension
                };
            }
            const contractObj = contracts[file.fileNameNoExtension];
            contractObj.abi = this.relativeToConfig(file.filePath);
        });
        const incompleteContracts = {};
        Object.values(contracts).forEach(contractObj => {
            if (!contractObj.abi || !contractObj.wasm) {
                delete contracts[contractObj.name];
                incompleteContracts[contractObj.name] = contractObj;
            }
        });
        Object.values(incompleteContracts).forEach(contractObj => {
            this.warn(`Contract "${contractObj.name}" is incomplete and missing either a WASM or ABI file: ${contractObj.wasm ||
                ``}${contractObj.abi || ``}`);
        });
        if (Object.keys(contracts).length === 0) {
            this.error("No contract to test was found. Make sure it is compiled and a .wasm and .abi file was created");
        }
        const responses = await inquirer.prompt([
            {
                type: `checkbox`,
                name: `contracts`,
                message: `What contracts would you like to test? Press <Enter> when done.`,
                choices: Object.values(contracts).map(c => ({
                    key: c.name,
                    value: c.name,
                    name: `${c.name} (${c.abi})`
                }))
            }
        ]);
        contracts = _.pickBy(contracts, val => responses.contracts.includes(val.name));
        return contracts;
    }
    async getAbis(contracts) {
        const abiMap = {};
        Object.values(contracts).forEach(c => {
            const abi = _.attempt(() => JSON.parse(fs.readFileSync(c.abi, `utf8`)));
            if (_.isError(abi)) {
                this.error(`Could not read ABI for contract "${c.name}": ${abi.message}`);
            }
            else {
                abiMap[c.name] = abi;
            }
        });
        return abiMap;
    }
    async getTables(abiMap) {
        const choices = Object.entries(abiMap).map(([name, abi]) => {
            return [
                new inquirer.Separator(`Contract ${name}`),
                ...abi.tables.map(table => ({
                    key: `${name}|${table.name}`,
                    value: `${name}|${table.name}`,
                    name: `${_.capitalize(table.name)}`
                }))
            ];
        });
        const responses = await inquirer.prompt([
            {
                type: `checkbox`,
                name: `tables`,
                message: `What tables would you like to fill with initial data? Press <Enter> when done.`,
                choices: _.flattenDeep(choices)
            }
        ]);
        const contractTablesMap = _.groupBy(responses.tables, value => value.split(`|`)[0]);
        Object.keys(contractTablesMap).forEach(contractName => {
            contractTablesMap[contractName] = contractTablesMap[contractName].map(value => value.split(`|`)[1]);
        });
        return contractTablesMap;
    }
    async bootstrapFixtures(fixturesDir, abiMap, tablesToBootstrap) {
        const contractsWithFixtures = [];
        for (const [contractName, tableNames] of Object.entries(tablesToBootstrap)) {
            if (tableNames.length === 0)
                continue;
            try {
                const contractFixtureDir = path.resolve(fixturesDir, `./${contractName}`);
                fs.ensureDirSync(contractFixtureDir);
                for (const tableName of tableNames) {
                    const fixtureTablePath = path.resolve(contractFixtureDir, `./${tableName}.json`);
                    if (fs.existsSync(fixtureTablePath)) {
                        this.log(`Fixtures for table ${contractName}::${tableName} already exist. Skipping ...`);
                        continue;
                    }
                    const abi = abiMap[contractName];
                    const tableRow = abi_1.createEmptyTableStruct(abi, tableName);
                    fs.writeFileSync(fixtureTablePath, JSON.stringify({
                        scope: [tableRow]
                    }, null, 4), `utf8`);
                }
                contractsWithFixtures.push(contractName);
            }
            catch (error) {
                this.error(error.message);
            }
        }
        return contractsWithFixtures;
    }
    async bootstrapTest(contracts, abiMap, testsDir, asTypeScript) {
        const template = fs.readFileSync(path.join(__dirname, asTypeScript
            ? `../templates/contract.test.template.ts`
            : `../templates/contract.test.template.js`), `utf8`);
        const compile = ejs.compile(template);
        const writeTemplate = (templateData) => {
            const testFilePath = path.resolve(testsDir, asTypeScript
                ? `./${templateData.contractName}.test.ts`
                : `./${templateData.contractName}.test.js`);
            if (fs.existsSync(testFilePath)) {
                this.log(`Tests for contract ${templateData.contractName} already exist. Skipping ...`);
            }
            else {
                const content = compile(templateData);
                const contentFormatted = prettier_1.default.format(content, {
                    parser: `babel`
                });
                fs.writeFileSync(testFilePath, contentFormatted);
            }
        };
        fs.ensureDirSync(testsDir);
        Object.values(contracts).forEach(contract => {
            // the import statement must be relative from cwd when the test script is run
            // i.e., same as package.json / config dir
            const hydraConfigRelativePath = path.relative(this.configDir, this.configFilePath);
            const abi = abiMap[contract.name];
            const exampleActionName = abi.actions[0] ? abi.actions[0].name : ``;
            const exampleActionPayload = exampleActionName
                ? JSON.stringify(abi_1.createEmptyActionPayload(abi, exampleActionName), null, 2)
                : `{}`;
            const exampleTableName = abi.tables[0] ? abi.tables[0].name : ``;
            const exampleTablePayload = exampleTableName
                ? JSON.stringify(abi_1.createEmptyTableStruct(abi, exampleTableName), null, 2)
                : `{}`;
            writeTemplate({
                contractName: contract.name,
                exampleActionName,
                exampleActionPayload,
                exampleTableName,
                exampleTablePayload,
                hydraConfigRelativePath
            });
        });
    }
    async writeConfig(contracts) {
        let existingHydraConfigObj = {};
        if (fs.existsSync(this.configFilePath)) {
            const content = fs.readFileSync(this.configFilePath, `utf8`);
            existingHydraConfigObj = yaml.safeLoad(content);
        }
        let hydraConfigObj = await hydra_1.createHydraConfig({ contracts });
        // merge existing into new to preserve config field
        hydraConfigObj = _.merge({}, hydraConfigObj, existingHydraConfigObj);
        const hydraConfigYaml = yaml.safeDump(hydraConfigObj, { sortKeys: true });
        fs.writeFileSync(this.configFilePath, hydraConfigYaml, {
            encoding: `utf8`
        });
        this.log(`Config written to ${this.configFilePath}`);
    }
    async writeHydraHeaderFile(testsDir) {
        const template = fs.readFileSync(path.join(__dirname, `../templates/hydra.hpp`), `utf8`);
        fs.writeFileSync(path.join(testsDir, `hydra.hpp`), template, `utf8`);
    }
    async initPackageWithTestEnvironment(contracts) {
        const packageJsonExists = fs.existsSync(`package.json`);
        if (packageJsonExists) {
            this.log(`Found an existing package.json file. Skipping jest testing-framework setup.`);
            return;
        }
        const template = fs.readFileSync(path.join(__dirname, `../templates/package.json`), `utf8`);
        const compile = ejs.compile(template);
        const contractNames = Object.keys(contracts);
        const packageName = _.kebabCase(contractNames[0] || `contract`);
        const content = compile({ packageName });
        fs.writeFileSync(`package.json`, content, `utf8`);
        this.log(`Installing testing dependencies ...`);
        child.execFileSync(`npm`, [`i`, `--quiet`]);
        const jestConfigExists = fs.existsSync(`jest.config.js`);
        if (jestConfigExists)
            return;
        this.log(`Setting up jest ...`);
        fs.copyFileSync(path.join(__dirname, `../templates/jest.config.js`), `jest.config.js`);
    }
    async run() {
        const { args, flags } = this.parse(Init);
        const contractsDir = path.resolve(process.cwd(), flags[`contracts-dir`] || `./`);
        const contracts = await this.getContracts(contractsDir);
        const abiMap = await this.getAbis(contracts);
        const tablesToBootstrap = await this.getTables(abiMap);
        const testsDir = path.resolve(process.cwd(), `./tests`);
        const fixturesDir = path.resolve(testsDir, `./fixtures`);
        const contractsWithFixtures = await this.bootstrapFixtures(fixturesDir, abiMap, tablesToBootstrap);
        // add fixturesPath relative to config dir
        contractsWithFixtures.forEach(name => {
            contracts[name].fixturesDir = path.relative(this.configDir, path.resolve(fixturesDir, `./${name}`));
        });
        await this.bootstrapTest(contracts, abiMap, testsDir, flags.typescript);
        await this.writeHydraHeaderFile(testsDir);
        await this.writeConfig(contracts);
        await this.initPackageWithTestEnvironment(contracts);
        this.log(`Done.`);
    }
}
exports.default = Init;
Init.description = `Sets up a testing environment for your EOSIO smart contracts`;
Init.examples = [
    `$ hydra init
$ hydra init --contracts-dir contracts
`
];
Init.flags = {
    "contracts-dir": command_1.flags.string({
        char: `c`,
        description: `path to search for contracts`,
        default: `./`,
        required: false // make flag required (this is not common and you should probably use an argument instead)
    }),
    typescript: command_1.flags.boolean({
        description: `create tests in TypeScript + Contract types`,
        default: false,
        required: false // make flag required (this is not common and you should probably use an argument instead)
    })
};
Init.args = [];
